// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package sql

import (
	"context"

	structs "github.com/0fau/logs/pkg/database/sql/structs"
	"github.com/jackc/pgx/v5/pgtype"
)

const areFriends = `-- name: AreFriends :one
SELECT EXISTS (SELECT 1
               FROM friends
               WHERE (user1 = $1 AND user2 = $2)
                  OR (user1 = $2 AND user2 = $1))
`

type AreFriendsParams struct {
	User1 pgtype.UUID
	User2 pgtype.UUID
}

func (q *Queries) AreFriends(ctx context.Context, arg AreFriendsParams) (bool, error) {
	row := q.db.QueryRow(ctx, areFriends, arg.User1, arg.User2)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createFriend = `-- name: CreateFriend :exec
INSERT INTO friends (user1, user2)
VALUES ($1, $2),
       ($2, $1)
ON CONFLICT (user1, user2) DO NOTHING
`

type CreateFriendParams struct {
	User1 pgtype.UUID
	User2 pgtype.UUID
}

func (q *Queries) CreateFriend(ctx context.Context, arg CreateFriendParams) error {
	_, err := q.db.Exec(ctx, createFriend, arg.User1, arg.User2)
	return err
}

const deleteEncounter = `-- name: DeleteEncounter :exec
DELETE
FROM encounters
WHERE id = $1
`

func (q *Queries) DeleteEncounter(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEncounter, id)
	return err
}

const deleteFriend = `-- name: DeleteFriend :exec
DELETE
FROM friends
WHERE (user1 = $1 AND user2 = $2)
   OR (user1 = $2 AND user2 = $1)
`

type DeleteFriendParams struct {
	User1 pgtype.UUID
	User2 pgtype.UUID
}

func (q *Queries) DeleteFriend(ctx context.Context, arg DeleteFriendParams) error {
	_, err := q.db.Exec(ctx, deleteFriend, arg.User1, arg.User2)
	return err
}

const deleteFriendRequest = `-- name: DeleteFriendRequest :exec
DELETE
FROM friend_requests
WHERE user1 = $1
  AND user2 = $2
`

type DeleteFriendRequestParams struct {
	User1 string
	User2 string
}

func (q *Queries) DeleteFriendRequest(ctx context.Context, arg DeleteFriendRequestParams) error {
	_, err := q.db.Exec(ctx, deleteFriendRequest, arg.User1, arg.User2)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const fetchWhitelist = `-- name: FetchWhitelist :one
DELETE
FROM whitelist
WHERE discord = $1
RETURNING role
`

func (q *Queries) FetchWhitelist(ctx context.Context, discord string) (string, error) {
	row := q.db.QueryRow(ctx, fetchWhitelist, discord)
	var role string
	err := row.Scan(&role)
	return role, err
}

const getEncounter = `-- name: GetEncounter :one
SELECT e.id, e.uploaded_by, e.uploaded_at, e.settings, e.thumbnail, e.tags, e.header, e.data, e.private, e.unique_hash, e.unique_group, e.visibility, e.boss, e.difficulty, e.date, e.duration, e.version, e.local_player,
       u.discord_id,
       u.discord_tag,
       u.log_visibility,
       u.username,
       u.avatar
FROM encounters e
         JOIN users u ON e.uploaded_by = u.id
WHERE e.id = $1
LIMIT 1
`

type GetEncounterRow struct {
	ID            int32
	UploadedBy    pgtype.UUID
	UploadedAt    pgtype.Timestamp
	Settings      structs.EncounterSettings
	Thumbnail     bool
	Tags          []string
	Header        structs.EncounterHeader
	Data          structs.EncounterData
	Private       bool
	UniqueHash    string
	UniqueGroup   int32
	Visibility    *structs.EncounterVisibility
	Boss          string
	Difficulty    string
	Date          pgtype.Timestamp
	Duration      int32
	Version       int32
	LocalPlayer   string
	DiscordID     string
	DiscordTag    string
	LogVisibility *structs.EncounterVisibility
	Username      *string
	Avatar        string
}

func (q *Queries) GetEncounter(ctx context.Context, id int32) (GetEncounterRow, error) {
	row := q.db.QueryRow(ctx, getEncounter, id)
	var i GetEncounterRow
	err := row.Scan(
		&i.ID,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.Settings,
		&i.Thumbnail,
		&i.Tags,
		&i.Header,
		&i.Data,
		&i.Private,
		&i.UniqueHash,
		&i.UniqueGroup,
		&i.Visibility,
		&i.Boss,
		&i.Difficulty,
		&i.Date,
		&i.Duration,
		&i.Version,
		&i.LocalPlayer,
		&i.DiscordID,
		&i.DiscordTag,
		&i.LogVisibility,
		&i.Username,
		&i.Avatar,
	)
	return i, err
}

const getEncounterShort = `-- name: GetEncounterShort :one
SELECT id,
       difficulty,
       uploaded_by,
       uploaded_at,
       settings,
       tags,
       header,
       boss,
       date,
       duration,
       local_player
FROM encounters
WHERE id = $1
LIMIT 1
`

type GetEncounterShortRow struct {
	ID          int32
	Difficulty  string
	UploadedBy  pgtype.UUID
	UploadedAt  pgtype.Timestamp
	Settings    structs.EncounterSettings
	Tags        []string
	Header      structs.EncounterHeader
	Boss        string
	Date        pgtype.Timestamp
	Duration    int32
	LocalPlayer string
}

func (q *Queries) GetEncounterShort(ctx context.Context, id int32) (GetEncounterShortRow, error) {
	row := q.db.QueryRow(ctx, getEncounterShort, id)
	var i GetEncounterShortRow
	err := row.Scan(
		&i.ID,
		&i.Difficulty,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.Settings,
		&i.Tags,
		&i.Header,
		&i.Boss,
		&i.Date,
		&i.Duration,
		&i.LocalPlayer,
	)
	return i, err
}

const getEncounterVisibility = `-- name: GetEncounterVisibility :one
SELECT uploaded_by, visibility
FROM encounters
WHERE id = $1
`

type GetEncounterVisibilityRow struct {
	UploadedBy pgtype.UUID
	Visibility *structs.EncounterVisibility
}

func (q *Queries) GetEncounterVisibility(ctx context.Context, id int32) (GetEncounterVisibilityRow, error) {
	row := q.db.QueryRow(ctx, getEncounterVisibility, id)
	var i GetEncounterVisibilityRow
	err := row.Scan(&i.UploadedBy, &i.Visibility)
	return i, err
}

const getHeader = `-- name: GetHeader :one
SELECT boss, difficulty, uploaded_by, date, duration, header
FROM encounters
WHERE id = $1
LIMIT 1
`

type GetHeaderRow struct {
	Boss       string
	Difficulty string
	UploadedBy pgtype.UUID
	Date       pgtype.Timestamp
	Duration   int32
	Header     structs.EncounterHeader
}

func (q *Queries) GetHeader(ctx context.Context, id int32) (GetHeaderRow, error) {
	row := q.db.QueryRow(ctx, getHeader, id)
	var i GetHeaderRow
	err := row.Scan(
		&i.Boss,
		&i.Difficulty,
		&i.UploadedBy,
		&i.Date,
		&i.Duration,
		&i.Header,
	)
	return i, err
}

const getNoThumbnailLogs = `-- name: GetNoThumbnailLogs :many
SELECT id
FROM encounters
WHERE thumbnail = false
ORDER BY id DESC
LIMIT 50
`

func (q *Queries) GetNoThumbnailLogs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, getNoThumbnailLogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoles = `-- name: GetRoles :one
SELECT roles
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetRoles(ctx context.Context, id pgtype.UUID) ([]string, error) {
	row := q.db.QueryRow(ctx, getRoles, id)
	var roles []string
	err := row.Scan(&roles)
	return roles, err
}

const getRolesByDiscordID = `-- name: GetRolesByDiscordID :one
SELECT id, roles
FROM users
WHERE discord_id = $1
LIMIT 1
`

type GetRolesByDiscordIDRow struct {
	ID    pgtype.UUID
	Roles []string
}

func (q *Queries) GetRolesByDiscordID(ctx context.Context, discordID string) (GetRolesByDiscordIDRow, error) {
	row := q.db.QueryRow(ctx, getRolesByDiscordID, discordID)
	var i GetRolesByDiscordIDRow
	err := row.Scan(&i.ID, &i.Roles)
	return i, err
}

const getRoster = `-- name: GetRoster :many
SELECT character, class, gear_score
FROM roster
WHERE user_id = $1
ORDER BY gear_score DESC, class
`

type GetRosterRow struct {
	Character string
	Class     string
	GearScore float64
}

func (q *Queries) GetRoster(ctx context.Context, userID pgtype.UUID) ([]GetRosterRow, error) {
	rows, err := q.db.Query(ctx, getRoster, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRosterRow
	for rows.Next() {
		var i GetRosterRow
		if err := rows.Scan(&i.Character, &i.Class, &i.GearScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRosterByUsername = `-- name: GetRosterByUsername :many
SELECT character, class, gear_score
FROM roster
         JOIN users u ON roster.user_id = u.id
WHERE LOWER(username) = LOWER($1)
ORDER BY gear_score DESC, class
`

type GetRosterByUsernameRow struct {
	Character string
	Class     string
	GearScore float64
}

func (q *Queries) GetRosterByUsername(ctx context.Context, lower string) ([]GetRosterByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getRosterByUsername, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRosterByUsernameRow
	for rows.Next() {
		var i GetRosterByUsernameRow
		if err := rows.Scan(&i.Character, &i.Class, &i.GearScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRosterStats = `-- name: GetRosterStats :many
SELECT DISTINCT(local_player) AS name, r.class, r.gear_score, COUNT(*)
FROM encounters e
         JOIN users u ON e.uploaded_by = u.id
         JOIN roster r ON u.id = r.user_id AND e.local_player = r.character
WHERE LOWER(u.username) = LOWER($1)
GROUP BY e.local_player, r.class, r.gear_score
ORDER BY gear_score DESC, local_player
`

type GetRosterStatsRow struct {
	Name      string
	Class     string
	GearScore float64
	Count     int64
}

func (q *Queries) GetRosterStats(ctx context.Context, lower string) ([]GetRosterStatsRow, error) {
	rows, err := q.db.Query(ctx, getRosterStats, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRosterStatsRow
	for rows.Next() {
		var i GetRosterStatsRow
		if err := rows.Scan(
			&i.Name,
			&i.Class,
			&i.GearScore,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRosterStatsByID = `-- name: GetRosterStatsByID :many
SELECT DISTINCT(local_player) AS name, r.class, r.gear_score, COUNT(*)
FROM encounters e
         JOIN users u ON e.uploaded_by = $1
         JOIN roster r ON u.id = r.user_id AND e.local_player = r.character
GROUP BY e.local_player, r.class, r.gear_score
ORDER BY gear_score DESC, local_player
`

type GetRosterStatsByIDRow struct {
	Name      string
	Class     string
	GearScore float64
	Count     int64
}

func (q *Queries) GetRosterStatsByID(ctx context.Context, uploadedBy pgtype.UUID) ([]GetRosterStatsByIDRow, error) {
	rows, err := q.db.Query(ctx, getRosterStatsByID, uploadedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRosterStatsByIDRow
	for rows.Next() {
		var i GetRosterStatsByIDRow
		if err := rows.Scan(
			&i.Name,
			&i.Class,
			&i.GearScore,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUniqueGroup = `-- name: GetUniqueGroup :one
SELECT unique_group
FROM encounters
WHERE unique_hash = $1
  AND unique_group = id
  AND (date + interval '120 seconds') >= $2
  AND (date - interval '120 seconds') <= $2
`

type GetUniqueGroupParams struct {
	UniqueHash string
	Date       pgtype.Timestamp
}

func (q *Queries) GetUniqueGroup(ctx context.Context, arg GetUniqueGroupParams) (int32, error) {
	row := q.db.QueryRow(ctx, getUniqueGroup, arg.UniqueHash, arg.Date)
	var unique_group int32
	err := row.Scan(&unique_group)
	return unique_group, err
}

const getUser = `-- name: GetUser :one
SELECT id, username, created_at, updated_at, access_token, discord_id, discord_tag, avatar, friends, settings, log_visibility, titles, roles
FROM users
WHERE discord_tag = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, discordTag string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, discordTag)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.DiscordID,
		&i.DiscordTag,
		&i.Avatar,
		&i.Friends,
		&i.Settings,
		&i.LogVisibility,
		&i.Titles,
		&i.Roles,
	)
	return i, err
}

const getUserByDiscordID = `-- name: GetUserByDiscordID :one
SELECT id, username, created_at, updated_at, access_token, discord_id, discord_tag, avatar, friends, settings, log_visibility, titles, roles
FROM users
WHERE discord_id = $1
LIMIT 1
`

func (q *Queries) GetUserByDiscordID(ctx context.Context, discordID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByDiscordID, discordID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.DiscordID,
		&i.DiscordTag,
		&i.Avatar,
		&i.Friends,
		&i.Settings,
		&i.LogVisibility,
		&i.Titles,
		&i.Roles,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, created_at, updated_at, access_token, discord_id, discord_tag, avatar, friends, settings, log_visibility, titles, roles
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.DiscordID,
		&i.DiscordTag,
		&i.Avatar,
		&i.Friends,
		&i.Settings,
		&i.LogVisibility,
		&i.Titles,
		&i.Roles,
	)
	return i, err
}

const getUserByToken = `-- name: GetUserByToken :one
SELECT id, username, created_at, updated_at, access_token, discord_id, discord_tag, avatar, friends, settings, log_visibility, titles, roles
FROM users
WHERE access_token = $1
LIMIT 1
`

func (q *Queries) GetUserByToken(ctx context.Context, accessToken *string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByToken, accessToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.DiscordID,
		&i.DiscordTag,
		&i.Avatar,
		&i.Friends,
		&i.Settings,
		&i.LogVisibility,
		&i.Titles,
		&i.Roles,
	)
	return i, err
}

const getUserEncounterVisibility = `-- name: GetUserEncounterVisibility :one
SELECT log_visibility
FROM users
WHERE id = $1
`

func (q *Queries) GetUserEncounterVisibility(ctx context.Context, id pgtype.UUID) (*structs.EncounterVisibility, error) {
	row := q.db.QueryRow(ctx, getUserEncounterVisibility, id)
	var log_visibility *structs.EncounterVisibility
	err := row.Scan(&log_visibility)
	return log_visibility, err
}

const hasFriendRequest = `-- name: HasFriendRequest :one
SELECT EXISTS (SELECT 1
               FROM friend_requests
               WHERE user1 = $1
                 AND user2 = $2)
`

type HasFriendRequestParams struct {
	User1 string
	User2 string
}

func (q *Queries) HasFriendRequest(ctx context.Context, arg HasFriendRequestParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasFriendRequest, arg.User1, arg.User2)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const insertCharacter = `-- name: InsertCharacter :exec
INSERT
INTO roster (user_id, character, class, gear_score)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, character)
    DO UPDATE SET gear_score = GREATEST(excluded.gear_score, roster.gear_score)
`

type InsertCharacterParams struct {
	UserID    pgtype.UUID
	Character string
	Class     string
	GearScore float64
}

func (q *Queries) InsertCharacter(ctx context.Context, arg InsertCharacterParams) error {
	_, err := q.db.Exec(ctx, insertCharacter,
		arg.UserID,
		arg.Character,
		arg.Class,
		arg.GearScore,
	)
	return err
}

const insertEncounter = `-- name: InsertEncounter :one
INSERT
INTO encounters (uploaded_by, settings, tags, header, data, version, difficulty, boss, date, duration,
                 local_player, unique_hash,
                 unique_group)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id
`

type InsertEncounterParams struct {
	UploadedBy  pgtype.UUID
	Settings    structs.EncounterSettings
	Tags        []string
	Header      structs.EncounterHeader
	Data        structs.EncounterData
	Version     int32
	Difficulty  string
	Boss        string
	Date        pgtype.Timestamp
	Duration    int32
	LocalPlayer string
	UniqueHash  string
	UniqueGroup int32
}

func (q *Queries) InsertEncounter(ctx context.Context, arg InsertEncounterParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertEncounter,
		arg.UploadedBy,
		arg.Settings,
		arg.Tags,
		arg.Header,
		arg.Data,
		arg.Version,
		arg.Difficulty,
		arg.Boss,
		arg.Date,
		arg.Duration,
		arg.LocalPlayer,
		arg.UniqueHash,
		arg.UniqueGroup,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

type InsertPlayerParams struct {
	Encounter  int32
	Boss       string
	Difficulty string
	Class      string
	Name       string
	Dead       bool
	GearScore  float64
	Dps        int64
	Place      int32
}

const insertPlayerInternal = `-- name: InsertPlayerInternal :exec
INSERT
INTO players (encounter, boss, difficulty, class, name, dead, gear_score, dps, place)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (encounter, name)
    DO UPDATE SET data = excluded.data
`

type InsertPlayerInternalParams struct {
	Encounter  int32
	Boss       string
	Difficulty string
	Class      string
	Name       string
	Dead       bool
	GearScore  float64
	Dps        int64
	Place      int32
}

func (q *Queries) InsertPlayerInternal(ctx context.Context, arg InsertPlayerInternalParams) error {
	_, err := q.db.Exec(ctx, insertPlayerInternal,
		arg.Encounter,
		arg.Boss,
		arg.Difficulty,
		arg.Class,
		arg.Name,
		arg.Dead,
		arg.GearScore,
		arg.Dps,
		arg.Place,
	)
	return err
}

const listEncounters = `-- name: ListEncounters :many
SELECT id
FROM encounters
ORDER BY uploaded_at
`

func (q *Queries) ListEncounters(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, listEncounters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriends = `-- name: ListFriends :many
SELECT u.discord_tag, u.username, f.date
FROM friends f
         JOIN users u on f.user2 = u.id
WHERE user1 = $1
`

type ListFriendsRow struct {
	DiscordTag string
	Username   *string
	Date       pgtype.Timestamp
}

func (q *Queries) ListFriends(ctx context.Context, user1 pgtype.UUID) ([]ListFriendsRow, error) {
	rows, err := q.db.Query(ctx, listFriends, user1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFriendsRow
	for rows.Next() {
		var i ListFriendsRow
		if err := rows.Scan(&i.DiscordTag, &i.Username, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReceivedFriendRequests = `-- name: ListReceivedFriendRequests :many
SELECT u.discord_tag, u.username, date
FROM friend_requests fr
         JOIN users u ON fr.user1 = u.discord_id
WHERE user2 = $1
`

type ListReceivedFriendRequestsRow struct {
	DiscordTag string
	Username   *string
	Date       pgtype.Timestamp
}

func (q *Queries) ListReceivedFriendRequests(ctx context.Context, user2 string) ([]ListReceivedFriendRequestsRow, error) {
	rows, err := q.db.Query(ctx, listReceivedFriendRequests, user2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListReceivedFriendRequestsRow
	for rows.Next() {
		var i ListReceivedFriendRequestsRow
		if err := rows.Scan(&i.DiscordTag, &i.Username, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSentFriendRequests = `-- name: ListSentFriendRequests :many
SELECT u.discord_tag, u.username, date
FROM friend_requests fr
         JOIN users u ON fr.user2 = u.discord_id
WHERE user1 = $1
`

type ListSentFriendRequestsRow struct {
	DiscordTag string
	Username   *string
	Date       pgtype.Timestamp
}

func (q *Queries) ListSentFriendRequests(ctx context.Context, user1 string) ([]ListSentFriendRequestsRow, error) {
	rows, err := q.db.Query(ctx, listSentFriendRequests, user1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSentFriendRequestsRow
	for rows.Next() {
		var i ListSentFriendRequestsRow
		if err := rows.Scan(&i.DiscordTag, &i.Username, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markThumbnail = `-- name: MarkThumbnail :exec
UPDATE encounters
SET thumbnail = true
WHERE id = $1
`

func (q *Queries) MarkThumbnail(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, markThumbnail, id)
	return err
}

const processEncounter = `-- name: ProcessEncounter :one
UPDATE encounters
SET header      = $2,
    data        = $3,
    unique_hash = $4
WHERE id = $1
RETURNING uploaded_by
`

type ProcessEncounterParams struct {
	ID         int32
	Header     structs.EncounterHeader
	Data       structs.EncounterData
	UniqueHash string
}

func (q *Queries) ProcessEncounter(ctx context.Context, arg ProcessEncounterParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, processEncounter,
		arg.ID,
		arg.Header,
		arg.Data,
		arg.UniqueHash,
	)
	var uploaded_by pgtype.UUID
	err := row.Scan(&uploaded_by)
	return uploaded_by, err
}

const sendFriendRequest = `-- name: SendFriendRequest :exec
INSERT INTO friend_requests (user1, user2)
VALUES ($1, $2)
`

type SendFriendRequestParams struct {
	User1 string
	User2 string
}

func (q *Queries) SendFriendRequest(ctx context.Context, arg SendFriendRequestParams) error {
	_, err := q.db.Exec(ctx, sendFriendRequest, arg.User1, arg.User2)
	return err
}

const setAccessToken = `-- name: SetAccessToken :exec
UPDATE users
SET access_token = $2
WHERE id = $1
`

type SetAccessTokenParams struct {
	ID          pgtype.UUID
	AccessToken *string
}

func (q *Queries) SetAccessToken(ctx context.Context, arg SetAccessTokenParams) error {
	_, err := q.db.Exec(ctx, setAccessToken, arg.ID, arg.AccessToken)
	return err
}

const setUserRoles = `-- name: SetUserRoles :exec
UPDATE users
SET roles = $2
WHERE discord_tag = $1
`

type SetUserRolesParams struct {
	DiscordTag string
	Roles      []string
}

func (q *Queries) SetUserRoles(ctx context.Context, arg SetUserRolesParams) error {
	_, err := q.db.Exec(ctx, setUserRoles, arg.DiscordTag, arg.Roles)
	return err
}

const setUsername = `-- name: SetUsername :exec
UPDATE users
SET username = $2
WHERE id = $1
`

type SetUsernameParams struct {
	ID       pgtype.UUID
	Username *string
}

func (q *Queries) SetUsername(ctx context.Context, arg SetUsernameParams) error {
	_, err := q.db.Exec(ctx, setUsername, arg.ID, arg.Username)
	return err
}

const updateAvatar = `-- name: UpdateAvatar :exec
UPDATE users
SET avatar = $2
WHERE id = $1
`

type UpdateAvatarParams struct {
	ID     pgtype.UUID
	Avatar string
}

func (q *Queries) UpdateAvatar(ctx context.Context, arg UpdateAvatarParams) error {
	_, err := q.db.Exec(ctx, updateAvatar, arg.ID, arg.Avatar)
	return err
}

const updateEncounterVisibility = `-- name: UpdateEncounterVisibility :exec
UPDATE encounters
SET visibility = $2
WHERE id = $1
`

type UpdateEncounterVisibilityParams struct {
	ID         int32
	Visibility *structs.EncounterVisibility
}

func (q *Queries) UpdateEncounterVisibility(ctx context.Context, arg UpdateEncounterVisibilityParams) error {
	_, err := q.db.Exec(ctx, updateEncounterVisibility, arg.ID, arg.Visibility)
	return err
}

const updateRoles = `-- name: UpdateRoles :exec
UPDATE users
SET roles = $2
WHERE id = $1
`

type UpdateRolesParams struct {
	ID    pgtype.UUID
	Roles []string
}

func (q *Queries) UpdateRoles(ctx context.Context, arg UpdateRolesParams) error {
	_, err := q.db.Exec(ctx, updateRoles, arg.ID, arg.Roles)
	return err
}

const updateUniqueGroup = `-- name: UpdateUniqueGroup :exec
UPDATE encounters
SET unique_group = $2
WHERE id = $1
`

type UpdateUniqueGroupParams struct {
	ID          int32
	UniqueGroup int32
}

func (q *Queries) UpdateUniqueGroup(ctx context.Context, arg UpdateUniqueGroupParams) error {
	_, err := q.db.Exec(ctx, updateUniqueGroup, arg.ID, arg.UniqueGroup)
	return err
}

const updateUserEncounterVisibility = `-- name: UpdateUserEncounterVisibility :exec
UPDATE users
SET log_visibility = $2
WHERE id = $1
`

type UpdateUserEncounterVisibilityParams struct {
	ID            pgtype.UUID
	LogVisibility *structs.EncounterVisibility
}

func (q *Queries) UpdateUserEncounterVisibility(ctx context.Context, arg UpdateUserEncounterVisibilityParams) error {
	_, err := q.db.Exec(ctx, updateUserEncounterVisibility, arg.ID, arg.LogVisibility)
	return err
}

const upsertEncounterGroup = `-- name: UpsertEncounterGroup :exec
INSERT
INTO grouped_encounters (group_id, uploaders)
VALUES ($1, ARRAY [$2::UUID])
ON CONFLICT (group_id)
    DO UPDATE SET uploaders = array_append(grouped_encounters.uploaders, $2)
`

type UpsertEncounterGroupParams struct {
	GroupID int32
	Column2 pgtype.UUID
}

func (q *Queries) UpsertEncounterGroup(ctx context.Context, arg UpsertEncounterGroupParams) error {
	_, err := q.db.Exec(ctx, upsertEncounterGroup, arg.GroupID, arg.Column2)
	return err
}

const upsertUser = `-- name: UpsertUser :one
INSERT
INTO users (discord_id, discord_tag, roles, avatar, settings)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (discord_id)
    DO UPDATE SET discord_tag = excluded.discord_tag,
                  roles       = excluded.roles
RETURNING id, username, created_at, updated_at, access_token, discord_id, discord_tag, avatar, friends, settings, log_visibility, titles, roles
`

type UpsertUserParams struct {
	DiscordID  string
	DiscordTag string
	Roles      []string
	Avatar     string
	Settings   structs.UserSettings
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.DiscordID,
		arg.DiscordTag,
		arg.Roles,
		arg.Avatar,
		arg.Settings,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.DiscordID,
		&i.DiscordTag,
		&i.Avatar,
		&i.Friends,
		&i.Settings,
		&i.LogVisibility,
		&i.Titles,
		&i.Roles,
	)
	return i, err
}

const whitelist = `-- name: Whitelist :exec
INSERT INTO whitelist (discord, role)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type WhitelistParams struct {
	Discord string
	Role    string
}

func (q *Queries) Whitelist(ctx context.Context, arg WhitelistParams) error {
	_, err := q.db.Exec(ctx, whitelist, arg.Discord, arg.Role)
	return err
}
