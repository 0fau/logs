// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: query.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getBuffs = `-- name: GetBuffs :many
SELECT encounter, player, buff_id, percent, damage
FROM buffs
WHERE encounter = $1
`

func (q *Queries) GetBuffs(ctx context.Context, encounter int32) ([]Buff, error) {
	rows, err := q.db.Query(ctx, getBuffs, encounter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Buff
	for rows.Next() {
		var i Buff
		if err := rows.Scan(
			&i.Encounter,
			&i.Player,
			&i.BuffID,
			&i.Percent,
			&i.Damage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEncounter = `-- name: GetEncounter :one
SELECT id, uploaded_by, visibility, title, description, raid, date, duration, total_damage_dealt, cleared, uploaded_at, tags, local_player
FROM encounters
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetEncounter(ctx context.Context, id int32) (Encounter, error) {
	row := q.db.QueryRow(ctx, getEncounter, id)
	var i Encounter
	err := row.Scan(
		&i.ID,
		&i.UploadedBy,
		&i.Visibility,
		&i.Title,
		&i.Description,
		&i.Raid,
		&i.Date,
		&i.Duration,
		&i.TotalDamageDealt,
		&i.Cleared,
		&i.UploadedAt,
		&i.Tags,
		&i.LocalPlayer,
	)
	return i, err
}

const getEntities = `-- name: GetEntities :many
SELECT encounter, class, enttype, name, damage, dps
FROM entities
WHERE encounter = $1
`

func (q *Queries) GetEntities(ctx context.Context, encounter int32) ([]Entity, error) {
	rows, err := q.db.Query(ctx, getEntities, encounter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entity
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.Encounter,
			&i.Class,
			&i.Enttype,
			&i.Name,
			&i.Damage,
			&i.Dps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSkills = `-- name: GetSkills :many
SELECT encounter, player, skill_id, casts, crits, dps, hits, max_damage, total_damage, name
FROM skills
WHERE encounter = $1
`

func (q *Queries) GetSkills(ctx context.Context, encounter int32) ([]Skill, error) {
	rows, err := q.db.Query(ctx, getSkills, encounter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Skill
	for rows.Next() {
		var i Skill
		if err := rows.Scan(
			&i.Encounter,
			&i.Player,
			&i.SkillID,
			&i.Casts,
			&i.Crits,
			&i.Dps,
			&i.Hits,
			&i.MaxDamage,
			&i.TotalDamage,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, discord_id, discord_name, access_token, roles, created_at, updated_at
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.DiscordName,
		&i.AccessToken,
		&i.Roles,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByToken = `-- name: GetUserByToken :one
SELECT id, discord_id, discord_name, access_token, roles, created_at, updated_at
FROM users
WHERE access_token = $1
LIMIT 1
`

func (q *Queries) GetUserByToken(ctx context.Context, accessToken pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByToken, accessToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.DiscordName,
		&i.AccessToken,
		&i.Roles,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type InsertBuffParams struct {
	Encounter int32
	Player    string
	BuffID    int32
	Percent   pgtype.Numeric
	Damage    int64
}

const insertEncounter = `-- name: InsertEncounter :one
INSERT
INTO encounters (uploaded_by, raid, date, visibility, duration, total_damage_dealt, cleared, local_player)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, uploaded_by, visibility, title, description, raid, date, duration, total_damage_dealt, cleared, uploaded_at, tags, local_player
`

type InsertEncounterParams struct {
	UploadedBy       pgtype.UUID
	Raid             string
	Date             pgtype.Timestamp
	Visibility       string
	Duration         int32
	TotalDamageDealt int64
	Cleared          bool
	LocalPlayer      string
}

func (q *Queries) InsertEncounter(ctx context.Context, arg InsertEncounterParams) (Encounter, error) {
	row := q.db.QueryRow(ctx, insertEncounter,
		arg.UploadedBy,
		arg.Raid,
		arg.Date,
		arg.Visibility,
		arg.Duration,
		arg.TotalDamageDealt,
		arg.Cleared,
		arg.LocalPlayer,
	)
	var i Encounter
	err := row.Scan(
		&i.ID,
		&i.UploadedBy,
		&i.Visibility,
		&i.Title,
		&i.Description,
		&i.Raid,
		&i.Date,
		&i.Duration,
		&i.TotalDamageDealt,
		&i.Cleared,
		&i.UploadedAt,
		&i.Tags,
		&i.LocalPlayer,
	)
	return i, err
}

const insertEntity = `-- name: InsertEntity :one
INSERT
INTO entities (encounter, class, enttype, name, damage, dps)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING encounter, class, enttype, name, damage, dps
`

type InsertEntityParams struct {
	Encounter int32
	Class     string
	Enttype   string
	Name      string
	Damage    int64
	Dps       int64
}

func (q *Queries) InsertEntity(ctx context.Context, arg InsertEntityParams) (Entity, error) {
	row := q.db.QueryRow(ctx, insertEntity,
		arg.Encounter,
		arg.Class,
		arg.Enttype,
		arg.Name,
		arg.Damage,
		arg.Dps,
	)
	var i Entity
	err := row.Scan(
		&i.Encounter,
		&i.Class,
		&i.Enttype,
		&i.Name,
		&i.Damage,
		&i.Dps,
	)
	return i, err
}

type InsertSkillParams struct {
	Encounter   int32
	Player      string
	SkillID     int32
	Casts       int32
	Crits       int32
	Dps         int64
	Hits        int32
	MaxDamage   int64
	TotalDamage int64
	Name        string
}

const listRecentEncounters = `-- name: ListRecentEncounters :many
SELECT id, uploaded_by, visibility, title, description, raid, date, duration, total_damage_dealt, cleared, uploaded_at, tags, local_player
FROM encounters
ORDER BY date DESC
LIMIT 5
`

func (q *Queries) ListRecentEncounters(ctx context.Context) ([]Encounter, error) {
	rows, err := q.db.Query(ctx, listRecentEncounters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Encounter
	for rows.Next() {
		var i Encounter
		if err := rows.Scan(
			&i.ID,
			&i.UploadedBy,
			&i.Visibility,
			&i.Title,
			&i.Description,
			&i.Raid,
			&i.Date,
			&i.Duration,
			&i.TotalDamageDealt,
			&i.Cleared,
			&i.UploadedAt,
			&i.Tags,
			&i.LocalPlayer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAccessToken = `-- name: SetAccessToken :exec
UPDATE users
SET access_token = $2
WHERE id = $1
`

type SetAccessTokenParams struct {
	ID          pgtype.UUID
	AccessToken pgtype.Text
}

func (q *Queries) SetAccessToken(ctx context.Context, arg SetAccessTokenParams) error {
	_, err := q.db.Exec(ctx, setAccessToken, arg.ID, arg.AccessToken)
	return err
}

const upsertUser = `-- name: UpsertUser :one
INSERT
INTO users (discord_id, discord_name)
VALUES ($1, $2)
ON CONFLICT (discord_id)
    DO UPDATE SET discord_name = excluded.discord_name
RETURNING id, discord_id, discord_name, access_token, roles, created_at, updated_at
`

type UpsertUserParams struct {
	DiscordID   string
	DiscordName string
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser, arg.DiscordID, arg.DiscordName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.DiscordName,
		&i.AccessToken,
		&i.Roles,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
