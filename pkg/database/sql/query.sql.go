// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: query.sql

package sql

import (
	"context"

	structs "github.com/0fau/logs/pkg/database/sql/structs"
	meter "github.com/0fau/logs/pkg/process/meter"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getData = `-- name: GetData :one
SELECT data
FROM encounters
WHERE id = $1
`

func (q *Queries) GetData(ctx context.Context, id int32) (structs.EncounterData, error) {
	row := q.db.QueryRow(ctx, getData, id)
	var data structs.EncounterData
	err := row.Scan(&data)
	return data, err
}

const getEncounter = `-- name: GetEncounter :one
SELECT id, uploaded_by, uploaded_at, settings, tags, header, data, boss, date, duration, local_player
FROM encounters
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetEncounter(ctx context.Context, id int32) (Encounter, error) {
	row := q.db.QueryRow(ctx, getEncounter, id)
	var i Encounter
	err := row.Scan(
		&i.ID,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.Settings,
		&i.Tags,
		&i.Header,
		&i.Data,
		&i.Boss,
		&i.Date,
		&i.Duration,
		&i.LocalPlayer,
	)
	return i, err
}

const getEntities = `-- name: GetEntities :many
SELECT encounter, enttype, name, class, damage, dps, dead, fields
FROM players
WHERE encounter = $1
`

func (q *Queries) GetEntities(ctx context.Context, encounter int32) ([]Player, error) {
	rows, err := q.db.Query(ctx, getEntities, encounter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.Encounter,
			&i.Enttype,
			&i.Name,
			&i.Class,
			&i.Damage,
			&i.Dps,
			&i.Dead,
			&i.Fields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSkills = `-- name: GetSkills :many
SELECT encounter, player, skill_id, name, dps, damage, tripods, fields
FROM skills
WHERE encounter = $1
`

func (q *Queries) GetSkills(ctx context.Context, encounter int32) ([]Skill, error) {
	rows, err := q.db.Query(ctx, getSkills, encounter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Skill
	for rows.Next() {
		var i Skill
		if err := rows.Scan(
			&i.Encounter,
			&i.Player,
			&i.SkillID,
			&i.Name,
			&i.Dps,
			&i.Damage,
			&i.Tripods,
			&i.Fields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, username, created_at, updated_at, access_token, discord_id, discord_tag, avatar, friends, settings, titles, roles
FROM users
WHERE discord_tag = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, discordTag string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, discordTag)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.DiscordID,
		&i.DiscordTag,
		&i.Avatar,
		&i.Friends,
		&i.Settings,
		&i.Titles,
		&i.Roles,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, created_at
FROM users
WHERE discord_tag = $1
LIMIT 1
`

type GetUserByIDRow struct {
	ID        pgtype.UUID
	CreatedAt pgtype.Timestamp
}

func (q *Queries) GetUserByID(ctx context.Context, discordTag string) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, discordTag)
	var i GetUserByIDRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const getUserByToken = `-- name: GetUserByToken :one
SELECT id, username, created_at, updated_at, access_token, discord_id, discord_tag, avatar, friends, settings, titles, roles
FROM users
WHERE access_token = $1
LIMIT 1
`

func (q *Queries) GetUserByToken(ctx context.Context, accessToken pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByToken, accessToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.DiscordID,
		&i.DiscordTag,
		&i.Avatar,
		&i.Friends,
		&i.Settings,
		&i.Titles,
		&i.Roles,
	)
	return i, err
}

const insertEncounter = `-- name: InsertEncounter :one
INSERT
INTO encounters (uploaded_by, settings, tags, header, data, boss, date, duration, local_player)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id
`

type InsertEncounterParams struct {
	UploadedBy  pgtype.UUID
	Settings    structs.EncounterSettings
	Tags        []string
	Header      structs.EncounterHeader
	Data        structs.EncounterData
	Boss        string
	Date        pgtype.Timestamp
	Duration    int32
	LocalPlayer string
}

func (q *Queries) InsertEncounter(ctx context.Context, arg InsertEncounterParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertEncounter,
		arg.UploadedBy,
		arg.Settings,
		arg.Tags,
		arg.Header,
		arg.Data,
		arg.Boss,
		arg.Date,
		arg.Duration,
		arg.LocalPlayer,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertEntity = `-- name: InsertEntity :one
INSERT
INTO players (encounter, class, enttype, name, damage, dps, dead, fields)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING encounter, enttype, name, class, damage, dps, dead, fields
`

type InsertEntityParams struct {
	Encounter int32
	Class     string
	Enttype   string
	Name      string
	Damage    int64
	Dps       int64
	Dead      bool
	Fields    []byte
}

func (q *Queries) InsertEntity(ctx context.Context, arg InsertEntityParams) (Player, error) {
	row := q.db.QueryRow(ctx, insertEntity,
		arg.Encounter,
		arg.Class,
		arg.Enttype,
		arg.Name,
		arg.Damage,
		arg.Dps,
		arg.Dead,
		arg.Fields,
	)
	var i Player
	err := row.Scan(
		&i.Encounter,
		&i.Enttype,
		&i.Name,
		&i.Class,
		&i.Damage,
		&i.Dps,
		&i.Dead,
		&i.Fields,
	)
	return i, err
}

type InsertSkillParams struct {
	Encounter int32
	Player    string
	SkillID   int32
	Dps       int64
	Damage    int64
	Name      string
	Tripods   meter.TripodRows
	Fields    meter.StoredSkillFields
}

const listRecentEncounters = `-- name: ListRecentEncounters :many
SELECT id,
       uploaded_by,
       uploaded_at,
       settings,
       tags,
       header,
       boss,
       date,
       duration,
       local_player
FROM encounters
WHERE ($1::TIMESTAMP IS NULL
    OR $1 > date)
  AND ($2::UUID IS NULL
    OR $2 = uploaded_by)
ORDER BY date DESC
LIMIT 5
`

type ListRecentEncountersParams struct {
	Date pgtype.Timestamp
	User pgtype.UUID
}

type ListRecentEncountersRow struct {
	ID          int32
	UploadedBy  pgtype.UUID
	UploadedAt  pgtype.Timestamp
	Settings    structs.EncounterSettings
	Tags        []string
	Header      structs.EncounterHeader
	Boss        string
	Date        pgtype.Timestamp
	Duration    int32
	LocalPlayer string
}

func (q *Queries) ListRecentEncounters(ctx context.Context, arg ListRecentEncountersParams) ([]ListRecentEncountersRow, error) {
	rows, err := q.db.Query(ctx, listRecentEncounters, arg.Date, arg.User)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentEncountersRow
	for rows.Next() {
		var i ListRecentEncountersRow
		if err := rows.Scan(
			&i.ID,
			&i.UploadedBy,
			&i.UploadedAt,
			&i.Settings,
			&i.Tags,
			&i.Header,
			&i.Boss,
			&i.Date,
			&i.Duration,
			&i.LocalPlayer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAccessToken = `-- name: SetAccessToken :exec
UPDATE users
SET access_token = $2
WHERE id = $1
`

type SetAccessTokenParams struct {
	ID          pgtype.UUID
	AccessToken pgtype.Text
}

func (q *Queries) SetAccessToken(ctx context.Context, arg SetAccessTokenParams) error {
	_, err := q.db.Exec(ctx, setAccessToken, arg.ID, arg.AccessToken)
	return err
}

const upsertUser = `-- name: UpsertUser :one
INSERT
INTO users (discord_id, discord_tag, avatar, settings)
VALUES ($1, $2, $3, $4)
ON CONFLICT (discord_id)
    DO UPDATE SET discord_tag = excluded.discord_tag,
                  avatar      = excluded.avatar
RETURNING id, username, created_at, updated_at, access_token, discord_id, discord_tag, avatar, friends, settings, titles, roles
`

type UpsertUserParams struct {
	DiscordID  string
	DiscordTag string
	Avatar     pgtype.Text
	Settings   structs.UserSettings
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.DiscordID,
		arg.DiscordTag,
		arg.Avatar,
		arg.Settings,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.DiscordID,
		&i.DiscordTag,
		&i.Avatar,
		&i.Friends,
		&i.Settings,
		&i.Titles,
		&i.Roles,
	)
	return i, err
}
